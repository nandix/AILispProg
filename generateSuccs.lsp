;------------------------------------------------------------------------------
; File: generateSuccs.lsp
;
; Author:		Dylan Geyer
;
; Description:	This file handles the generation of child states given a parent state.
;				it uses the find-atom to locate the blank space in a parent state to 
;				determine if it can be moved up/down/left/right.
;				
;				The state representation is ((123)(456)(780)). This allows us to move
;				the 0 left 1 index, right 1 index, up one row, or down one row.
;------------------------------------------------------------------------------

;------------------------------------------------------------------------------
; Function: 	find-atom
;
; Author:		Dylan Geyer
;
; Description:	This function is specifically written to find an atom in a 2d list.
;               This means every item in the parent list must be a list and every
;               item in the sublist must be an atom. This is the format that our
;               node-state is in. This function loops through each sublist and
;               uses (position) to find the position of the specified atom.
;
; Parameters:	atom - The atom that is being searched for
;               lst - list to be searched for the atom, MUST BE 2D (list of sublists)
;
; Return:		(row col) - list that contains row index and col index
;------------------------------------------------------------------------------
(defun find-atom (&optional (atom 0) (lst '()))
	(let ((r 0) (c 0))
		(loop for row in lst do
			(setf c (position atom row :test #'equal))
			(cond
				( (null c)  ;If atom was not found in this row, increment row and look at next row
					(setf r (1+ r))
				)
				(t  ;Atom was found! return the row and column that it was found at
					(return-from find-atom (list r c))
				)
			)
		)
	)
)

;------------------------------------------------------------------------------
; Function: 	generate-successors
;
; Author:		Dylan Geyer
;
; Description:	This function will return a list of all of the states that can be
;               generated by moving the blank space up/down/left/right. This state
;               will return anywhere from 2 to 4 states.
;
; Parameters:	lst - state that the blank space is to be moved from
;
; Return:		list of all possible moves of the blank space from lst
;------------------------------------------------------------------------------
(defun generate-successors (lst)
	(let 
		(
			(pos nil) 
			(row nil) 
			(col nil) 
			(puzCopy nil) 
			(len nil)
			(children '()) 
		)

		(setf pos (find-atom 0 lst))    ;Find the zero (blank space) in parent state

		(setf row (car pos))
		(setf col (car (cdr pos)))
		(setf len (length lst))


		(cond
			( (>= row 1)	;If row index is >= 1 then we can move our zero UP
				(setf puzCopy (copy-tree lst))
				(rotatef (nth col (nth row puzCopy)) (nth col (nth (1- row) puzCopy)))
				(setf children (append children (list (copy-tree puzCopy))))
				(incf *nodeCount*)
			)
		)
		(cond
			( (< row (1- len))	;If row index is < len then we can move our zero DOWN
				(setf puzCopy (copy-tree lst))
				(rotatef (nth col (nth row puzCopy)) (nth col (nth (1+ row) puzCopy)))
				(setf children (append children (list (copy-tree puzCopy))))
				(incf *nodeCount*)
			)
		)
		(cond
			( (>= col 1)	;If col index is >= 1 then we can move our zero LEFT
				(setf puzCopy (copy-tree lst))
				(rotatef (nth col (nth row puzCopy)) (nth (1- col) (nth row puzCopy)))
				(setf children (append children (list (copy-tree puzCopy))))
				(incf *nodeCount*)
			)
		)
		(cond
			( ( < col (1- len))	;If col index is < len then we can move our zero RIGHT
				(setf puzCopy (copy-tree lst))
				(rotatef (nth col (nth row puzCopy)) (nth (1+ col) (nth row puzCopy)))
				(setf children (append children (list (copy-tree puzCopy))))
				(incf *nodeCount*)
			)
		)
		(return-from generate-successors children)
	)
)
